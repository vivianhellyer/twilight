<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `twilight_standby` crate."><meta name="keywords" content="rust, rustlang, rust-lang, twilight_standby"><title>twilight_standby - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../twilight_standby/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate twilight_standby</p><div class='block version'><p>Version 0.1.0</p></div><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all twilight_standby's items</p></a><div class="block items"><ul><li><a href="#structs">Structs</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'twilight_standby', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/twilight_standby/lib.rs.html#1-1078' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>twilight_standby</a></span></h1><div class='docblock'><h1 id="twilight-standby" class="section-header"><a href="#twilight-standby">twilight-standby</a></h1>
<p>Standby is a utility to wait for an event to happen based on a predicate
check. For example, you may have a command that has a reaction menu of ✅ and
❌. If you want to handle a reaction to these, using something like an
application-level state or event stream may not suit your use case. It may
be cleaner to wait for a reaction inline to your function. This is where
Twilight Standby comes in.</p>
<p>Standby allows you to wait for things like an event in a certain guild
(<a href="struct.Standby.html#method.wait_for"><code>Standby::wait_for</code></a>), a new message in a channel
(<a href="struct.Standby.html#method.wait_for_message"><code>Standby::wait_for_message</code></a>), a new reaction on a message
(<a href="struct.Standby.html#method.wait_for_reaction"><code>Standby::wait_for_reaction</code></a>), and any event that might not take place in
a guild, such as a new <code>Ready</code> event (<a href="struct.Standby.html#method.wait_for_event"><code>Standby::wait_for_event</code></a>). Each
method also has a stream variant.</p>
<p>To use Standby, you must process events with it in your main event loop.
Check out the <a href="struct.Standby.html#method.process"><code>Standby::process</code></a> method.</p>
<h2 id="when-to-use-futures-and-streams" class="section-header"><a href="#when-to-use-futures-and-streams">When to use futures and streams</a></h2>
<p><code>Standby</code> has two variants of each method: a future variant and a stream
variant. An example is <a href="struct.Standby.html#method.wait_for_message"><code>Standby::wait_for_message</code></a>, which also has a
<a href="struct.Standby.html#method.wait_for_message_stream"><code>Standby::wait_for_message_stream</code></a> variant. The future variant is useful
when you want to oneshot an event that you need to wait for. This means that
if you only need to wait for one message in a channel to come in, you'd use
the future variant. If you need to wait for multiple messages, such as maybe
all of the messages within a minute's timespan, you'd use the
<a href="struct.Standby.html#method.wait_for_message_stream"><code>Standby::wait_for_message_stream</code></a> method.</p>
<p>The difference is that if you use the futures variant in a loop then you may
miss some events while processing a received event. By using a stream, you
won't miss any events.</p>
<h2 id="examples" class="section-header"><a href="#examples">Examples</a></h2><h3 id="at-a-glance" class="section-header"><a href="#at-a-glance">At a glance</a></h3>
<p>Wait for a message in channel 123 by user 456 with the content &quot;test&quot;:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">twilight_model</span>::{<span class="ident">gateway</span>::<span class="ident">payload</span>::<span class="ident">MessageCreate</span>, <span class="ident">id</span>::{<span class="ident">ChannelId</span>, <span class="ident">UserId</span>}};
<span class="kw">use</span> <span class="ident">twilight_standby</span>::<span class="ident">Standby</span>;

<span class="kw">let</span> <span class="ident">standby</span> <span class="op">=</span> <span class="ident">Standby</span>::<span class="ident">new</span>();

<span class="kw">let</span> <span class="ident">message</span> <span class="op">=</span> <span class="ident">standby</span>.<span class="ident">wait_for_message</span>(<span class="ident">ChannelId</span>(<span class="number">123</span>), <span class="op">|</span><span class="ident">event</span>: <span class="kw-2">&amp;</span><span class="ident">MessageCreate</span><span class="op">|</span> {
    <span class="ident">event</span>.<span class="ident">author</span>.<span class="ident">id</span> <span class="op">==</span> <span class="ident">UserId</span>(<span class="number">456</span>) <span class="op">&amp;&amp;</span> <span class="ident">event</span>.<span class="ident">content</span> <span class="op">==</span> <span class="string">&quot;test&quot;</span>
}).<span class="kw">await</span><span class="question-mark">?</span>;</pre></div>
<h3 id="a-full-example" class="section-header"><a href="#a-full-example">A full example</a></h3>
<p>A full sample bot connecting to the gateway, processing events, and
including a handler to wait for reactions:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures_util</span>::<span class="ident">StreamExt</span>;
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">env</span>, <span class="ident">error</span>::<span class="ident">Error</span>};
<span class="kw">use</span> <span class="ident">twilight_gateway</span>::{<span class="ident">Event</span>, <span class="ident">Shard</span>};
<span class="kw">use</span> <span class="ident">twilight_model</span>::{
    <span class="ident">channel</span>::<span class="ident">Message</span>,
    <span class="ident">gateway</span>::<span class="ident">payload</span>::<span class="ident">ReactionAdd</span>,
    <span class="ident">id</span>::{<span class="ident">ChannelId</span>, <span class="ident">UserId</span>},
};
<span class="kw">use</span> <span class="ident">twilight_standby</span>::<span class="ident">Standby</span>;

<span class="attribute">#[<span class="ident">tokio</span>::<span class="ident">main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">Error</span><span class="op">&gt;&gt;</span> {
    <span class="comment">// Start a shard connected to the gateway to receive events.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">shard</span> <span class="op">=</span> <span class="ident">Shard</span>::<span class="ident">new</span>(<span class="ident">env</span>::<span class="ident">var</span>(<span class="string">&quot;DISCORD_TOKEN&quot;</span>)<span class="question-mark">?</span>);
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">events</span> <span class="op">=</span> <span class="ident">shard</span>.<span class="ident">events</span>().<span class="kw">await</span>;
    <span class="ident">shard</span>.<span class="ident">start</span>().<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="kw">let</span> <span class="ident">standby</span> <span class="op">=</span> <span class="ident">Standby</span>::<span class="ident">new</span>();

    <span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">event</span>) <span class="op">=</span> <span class="ident">events</span>.<span class="ident">next</span>().<span class="kw">await</span> {
        <span class="comment">// Have standby process the event, which will fulfill any futures that</span>
        <span class="comment">// are waiting for an event.</span>
        <span class="ident">standby</span>.<span class="ident">process</span>(<span class="kw-2">&amp;</span><span class="ident">event</span>);

        <span class="kw">match</span> <span class="ident">event</span> {
            <span class="ident">Event</span>::<span class="ident">MessageCreate</span>(<span class="ident">msg</span>) <span class="kw">if</span> <span class="ident">msg</span>.<span class="ident">content</span> <span class="op">==</span> <span class="string">&quot;!react&quot;</span> <span class="op">=&gt;</span> {
                <span class="ident">tokio</span>::<span class="ident">spawn</span>(<span class="ident">react</span>(<span class="ident">msg</span>.<span class="number">0</span>, <span class="ident">standby</span>.<span class="ident">clone</span>()));
            },
            <span class="kw">_</span> <span class="op">=&gt;</span> {},
        }
    }

    <span class="prelude-val">Ok</span>(())
}

<span class="comment">// Wait for a reaction from the user who sent the message, and then print it</span>
<span class="comment">// once they react.</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">react</span>(<span class="ident">msg</span>: <span class="ident">Message</span>, <span class="ident">standby</span>: <span class="ident">Standby</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">Error</span> <span class="op">+</span> <span class="ident">Send</span> <span class="op">+</span> <span class="ident">Sync</span> <span class="op">+</span> <span class="lifetime">&#39;static</span><span class="op">&gt;&gt;</span> {
    <span class="kw">let</span> <span class="ident">author_id</span> <span class="op">=</span> <span class="ident">msg</span>.<span class="ident">author</span>.<span class="ident">id</span>;

    <span class="kw">let</span> <span class="ident">reaction</span> <span class="op">=</span> <span class="ident">standby</span>.<span class="ident">wait_for_reaction</span>(<span class="ident">msg</span>.<span class="ident">id</span>, <span class="kw">move</span> <span class="op">|</span><span class="ident">event</span>: <span class="kw-2">&amp;</span><span class="ident">ReactionAdd</span><span class="op">|</span> {
        <span class="ident">event</span>.<span class="ident">user_id</span> <span class="op">==</span> <span class="ident">author_id</span>
    }).<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;user reacted with {:?}&quot;</span>, <span class="ident">reaction</span>.<span class="ident">emoji</span>);

    <span class="prelude-val">Ok</span>(())
}</pre></div>
<p>For more examples, check out each of the methods on <a href="struct.Standby.html"><code>Standby</code></a>.</p>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.Standby.html" title='twilight_standby::Standby struct'>Standby</a></td><td class='docblock-short'><p>The <code>Standby</code> struct, used by the main event loop to process events and by
tasks to wait for an event.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.WaitForEventFuture.html" title='twilight_standby::WaitForEventFuture struct'>WaitForEventFuture</a></td><td class='docblock-short'><p>The future returned from <a href="struct.Standby.html#method.wait_for_event"><code>Standby::wait_for_event</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.WaitForEventStream.html" title='twilight_standby::WaitForEventStream struct'>WaitForEventStream</a></td><td class='docblock-short'><p>The stream returned from <a href="struct.Standby.html#method.wait_for_event_stream"><code>Standby::wait_for_event_stream</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.WaitForGuildEventFuture.html" title='twilight_standby::WaitForGuildEventFuture struct'>WaitForGuildEventFuture</a></td><td class='docblock-short'><p>The future returned from <a href="struct.Standby.html#method.wait_for"><code>Standby::wait_for</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.WaitForGuildEventStream.html" title='twilight_standby::WaitForGuildEventStream struct'>WaitForGuildEventStream</a></td><td class='docblock-short'><p>The stream returned from <a href="struct.Standby.html#method.wait_for_guild_event_stream"><code>Standby::wait_for_guild_event_stream</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.WaitForMessageFuture.html" title='twilight_standby::WaitForMessageFuture struct'>WaitForMessageFuture</a></td><td class='docblock-short'><p>The future returned from <a href="struct.Standby.html#method.wait_for_message"><code>Standby::wait_for_message</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.WaitForMessageStream.html" title='twilight_standby::WaitForMessageStream struct'>WaitForMessageStream</a></td><td class='docblock-short'><p>The stream returned from <a href="struct.Standby.html#method.wait_for_message_stream"><code>Standby::wait_for_message_stream</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.WaitForReactionFuture.html" title='twilight_standby::WaitForReactionFuture struct'>WaitForReactionFuture</a></td><td class='docblock-short'><p>The future returned from <a href="struct.Standby.html#method.wait_for_reaction"><code>Standby::wait_for_reaction</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.WaitForReactionStream.html" title='twilight_standby::WaitForReactionStream struct'>WaitForReactionStream</a></td><td class='docblock-short'><p>The stream returned from <a href="struct.Standby.html#method.wait_for_reaction_stream"><code>Standby::wait_for_reaction_stream</code></a>.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "twilight_standby";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>